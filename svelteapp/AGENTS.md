# **AGENTS.md（Svelte 前端开发规范版）**

### Svelte Frontend Code Authoring Principles for AI Agents

> 本文件在通用前端理念（组件清晰 / 状态可控 / 可测试）基础上，补充 **Svelte / SvelteKit** 的工程实践约束。编写风格与总规范保持一致，并参考 `agent-specs/engineering/frontend/AGENTS.md` 的方法论。

---

# **🔒 操作边界（必须遵守）**

1. **文档可写，代码禁写（默认）**
   - 在未获得人类明确授权前：仅允许输出建议与示例（纯文本），不得写入/修改任何 `.svelte` / `.ts` / `.js` 源码文件。
2. **获得明确授权后才可写代码**
   - 仅当人类提供明确指令（例如 `WRITE_CODE:`）后，AI 才能对相关源码进行写入或修改。
3. **若请求存在歧义，先确认**
   - 必须先问清楚“需要我直接改文件，还是只输出文本建议？”再继续。

---

# **📘 概述**

Svelte 的核心特性是 **编译时优化（compile-time）** 与 **直观的响应式表达**。它的风险也很明确：

* 响应式依赖与副作用如果混在一起，容易产生隐式流程
* store/模块级状态若无约束，容易引入跨页面污染与难测问题
* 在 SvelteKit 中，SSR/CSR、load、form actions、hooks 等边界如果混用，容易造成数据流混乱

因此，本规范强调：**边界清晰、数据流可追踪、可测试、可访问性优先、避免魔法**。

---

# **🎯 AI 编写 Svelte 前端代码的核心目标**

1. **组件清晰（Component Clarity）**
2. **状态可控（Predictable State / Store Discipline）**
3. **SSR/CSR 边界明确（SvelteKit Boundaries）**
4. **可维护样式（Scalable Styling）**
5. **可测试与可访问性（Testability & a11y）**

---

# **🧠 Svelte / SvelteKit 十大黄金法则**

## **📌 法则 1：组件职责单一，避免“页面神组件”**

* 页面组件负责布局与编排，不承载复杂业务规则
* 可复用逻辑抽到 `lib/`（组件、stores、utils、services）并保持粒度清晰

---

## **📌 法则 2：响应式表达要显式，副作用要隔离**

* 计算型响应式应保持纯净（只计算，不做 IO）
* 副作用（请求/订阅/计时器）必须集中管理并明确清理逻辑（生命周期/取消）
* 不允许在响应式链路里“顺手做一点事”导致流程不可见

---

## **📌 法则 3：store 使用要节制：局部优先，全局最小化**

* 优先组件局部状态；跨组件共享才引入 store
* store 命名体现领域语义；禁止用“万能 store”承载全部状态
* store 的写入必须有唯一入口（service/use-case 风格），避免到处 `set/update`

---

## **📌 法则 4：SvelteKit 数据边界要清晰：load / actions / hooks 各司其职**

* `load`：只负责数据装配与权限前置检查（不把业务流程塞进页面渲染）
* `actions`：只处理表单提交的命令式行为（校验、调用服务、返回稳定结果）
* `hooks`：只做跨请求的横切逻辑（鉴权/注入/追踪），禁止塞业务

---

## **📌 法则 5：UI = f(state)，避免 DOM 驱动逻辑**

* 状态驱动渲染，不通过手工读写 DOM 来推进业务流程
* 事件处理函数只做：输入处理 → 调用服务 → 更新状态 → 渲染反映结果

---

## **📌 法则 6：类型与契约要明确（尤其是 props 与边界数据）**

* `export let ...` 的输入应有清晰约束（类型/默认值/可空性）
* 对外边界（API 返回、表单输入）必须做校验/归一化，避免 `any` 贯穿

---

## **📌 法则 7：可访问性优先（a11y）**

* 交互元素使用语义化标签，必要时补充 aria 属性
* 键盘可达、焦点管理清晰、错误提示对屏幕阅读器友好
* 不要为了“消除告警”而草率禁用 a11y 检查

---

## **📌 法则 8：样式要可维护：局部化、可组合、避免全局污染**

* 默认使用组件内样式或明确的样式系统（例如 CSS Variables / utility-first）
* 禁止无边界的全局选择器污染；必须有命名空间或顶层容器约束
* 复杂布局/主题优先抽取为可复用 token（颜色/间距/字体）

---

## **📌 法则 9：错误与加载状态必须显式建模**

* 对用户可见：loading / empty / error / success 四态明确
* 对开发者可观测：错误要带上下文但不得泄露敏感信息
* 对提交动作：按钮 disable、重复提交防护、可撤销/可重试策略要清晰

---

## **📌 法则 10：可测试性设计：把纯逻辑从组件中剥离**

* 纯逻辑写成纯函数/服务层，组件只做渲染与调用
* 关键业务流必须可在无 UI 情况下单测（输入 → 输出）
* UI 测试按用户行为验证（渲染、点击、提交、可访问性）

---

# **🧩 推荐目录结构（SvelteKit，示例）**

> 仅作结构参考，实际以仓库既有约定为准。

```
/src
  /lib
    /components
    /stores
    /services
    /utils
  /routes
    /(app)
      +layout.svelte
      +page.svelte
      +page.ts
      +page.server.ts
      +server.ts
```

原则：

* `routes` 只负责路由与页面编排
* 领域/服务逻辑落在 `lib/services`（或仓库既定目录）
* stores 只承载必要共享状态，避免“全局状态大杂烩”

---

# **✅ 输出要求（AI 生成 Svelte 代码时）**

* 默认输出：结构设计 + 数据流说明（state/store/load/actions）+ 关键组件拆分 + 示例代码（纯文本）
* 若被允许落盘修改代码：必须同时给出变更清单与验证口径（如何运行/如何回归/覆盖哪些场景）

